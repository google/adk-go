// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package auth

// AuthCredentialType defines the type of credential.
type AuthCredentialType string

const (
	// AuthCredentialTypeAPIKey for API key credentials.
	AuthCredentialTypeAPIKey AuthCredentialType = "apiKey"
	// AuthCredentialTypeHTTP for HTTP credentials (Basic, Bearer, etc).
	AuthCredentialTypeHTTP AuthCredentialType = "http"
	// AuthCredentialTypeOAuth2 for OAuth2 credentials.
	AuthCredentialTypeOAuth2 AuthCredentialType = "oauth2"
	// AuthCredentialTypeOpenIDConnect for OpenID Connect credentials.
	AuthCredentialTypeOpenIDConnect AuthCredentialType = "openIdConnect"
	// AuthCredentialTypeServiceAccount for Google Service Account credentials.
	AuthCredentialTypeServiceAccount AuthCredentialType = "serviceAccount"
)

// AuthCredential holds authentication credentials.
// The actual credential data is stored in one of the type-specific fields
// based on AuthType.
type AuthCredential struct {
	// AuthType specifies which credential field to use.
	AuthType AuthCredentialType `json:"authType"`
	// ResourceRef is used to reference credentials from external sources.
	ResourceRef string `json:"resourceRef,omitempty"`
	// APIKey contains the API key value (for AuthCredentialTypeAPIKey).
	APIKey string `json:"apiKey,omitempty"`
	// HTTP contains HTTP auth credentials (for AuthCredentialTypeHTTP).
	HTTP *HTTPAuth `json:"http,omitempty"`
	// OAuth2 contains OAuth2 credentials (for AuthCredentialTypeOAuth2 and OpenIDConnect).
	OAuth2 *OAuth2Auth `json:"oauth2,omitempty"`
	// ServiceAccount contains Google service account credentials.
	ServiceAccount *ServiceAccount `json:"serviceAccount,omitempty"`
}

// HTTPAuth contains HTTP authentication credentials.
type HTTPAuth struct {
	// Scheme is the HTTP authentication scheme (e.g., "basic", "bearer").
	Scheme string `json:"scheme"`
	// Credentials contains the actual credential values.
	Credentials *HTTPCredentials `json:"credentials"`
}

// HTTPCredentials contains username/password or token for HTTP auth.
type HTTPCredentials struct {
	Username string `json:"username,omitempty"`
	Password string `json:"password,omitempty"`
	Token    string `json:"token,omitempty"`
}

// OAuth2Auth contains OAuth2 credentials and tokens.
type OAuth2Auth struct {
	// ClientID is the OAuth2 client ID.
	ClientID string `json:"clientId,omitempty"`
	// ClientSecret is the OAuth2 client secret.
	ClientSecret string `json:"clientSecret,omitempty"`
	// AuthURI is the authorization URI (generated by ADK or provided).
	AuthURI string `json:"authUri,omitempty"`
	// State is the OAuth state parameter for CSRF protection.
	State string `json:"state,omitempty"`
	// RedirectURI is the callback URI for OAuth flow.
	RedirectURI string `json:"redirectUri,omitempty"`
	// AuthResponseURI is the response from the OAuth provider after auth.
	AuthResponseURI string `json:"authResponseUri,omitempty"`
	// AuthCode is the authorization code from OAuth flow.
	AuthCode string `json:"authCode,omitempty"`
	// AccessToken is the obtained access token.
	AccessToken string `json:"accessToken,omitempty"`
	// RefreshToken is the refresh token for obtaining new access tokens.
	RefreshToken string `json:"refreshToken,omitempty"`
	// ExpiresAt is the Unix timestamp when the access token expires.
	ExpiresAt int64 `json:"expiresAt,omitempty"`
	// ExpiresIn is the token validity duration in seconds.
	ExpiresIn int64 `json:"expiresIn,omitempty"`
	// Audience is the intended audience for the token.
	Audience string `json:"audience,omitempty"`
	// TokenEndpointAuthMethod specifies how to authenticate at the token endpoint.
	TokenEndpointAuthMethod string `json:"tokenEndpointAuthMethod,omitempty"`
}

// ServiceAccount contains Google service account credentials.
type ServiceAccount struct {
	// ServiceAccountCredential contains the parsed JSON key file.
	ServiceAccountCredential *ServiceAccountCredential `json:"serviceAccountCredential,omitempty"`
	// Scopes are the OAuth scopes to request.
	Scopes []string `json:"scopes"`
	// UseDefaultCredential indicates whether to use Application Default Credentials.
	UseDefaultCredential bool `json:"useDefaultCredential,omitempty"`
}

// ServiceAccountCredential represents a Google Service Account JSON key file.
type ServiceAccountCredential struct {
	Type                    string `json:"type"`
	ProjectID               string `json:"project_id"`
	PrivateKeyID            string `json:"private_key_id"`
	PrivateKey              string `json:"private_key"`
	ClientEmail             string `json:"client_email"`
	ClientID                string `json:"client_id"`
	AuthURI                 string `json:"auth_uri"`
	TokenURI                string `json:"token_uri"`
	AuthProviderX509CertURL string `json:"auth_provider_x509_cert_url"`
	ClientX509CertURL       string `json:"client_x509_cert_url"`
	UniverseDomain          string `json:"universe_domain"`
}

// Copy creates a deep copy of the AuthCredential.
func (c *AuthCredential) Copy() *AuthCredential {
	if c == nil {
		return nil
	}
	newCred := &AuthCredential{
		AuthType:    c.AuthType,
		ResourceRef: c.ResourceRef,
		APIKey:      c.APIKey,
	}
	if c.HTTP != nil {
		newCred.HTTP = &HTTPAuth{
			Scheme: c.HTTP.Scheme,
		}
		if c.HTTP.Credentials != nil {
			newCred.HTTP.Credentials = &HTTPCredentials{
				Username: c.HTTP.Credentials.Username,
				Password: c.HTTP.Credentials.Password,
				Token:    c.HTTP.Credentials.Token,
			}
		}
	}
	if c.OAuth2 != nil {
		newCred.OAuth2 = &OAuth2Auth{
			ClientID:                c.OAuth2.ClientID,
			ClientSecret:            c.OAuth2.ClientSecret,
			AuthURI:                 c.OAuth2.AuthURI,
			State:                   c.OAuth2.State,
			RedirectURI:             c.OAuth2.RedirectURI,
			AuthResponseURI:         c.OAuth2.AuthResponseURI,
			AuthCode:                c.OAuth2.AuthCode,
			AccessToken:             c.OAuth2.AccessToken,
			RefreshToken:            c.OAuth2.RefreshToken,
			ExpiresAt:               c.OAuth2.ExpiresAt,
			ExpiresIn:               c.OAuth2.ExpiresIn,
			Audience:                c.OAuth2.Audience,
			TokenEndpointAuthMethod: c.OAuth2.TokenEndpointAuthMethod,
		}
	}
	if c.ServiceAccount != nil {
		newCred.ServiceAccount = &ServiceAccount{
			Scopes:               append([]string{}, c.ServiceAccount.Scopes...),
			UseDefaultCredential: c.ServiceAccount.UseDefaultCredential,
		}
		if c.ServiceAccount.ServiceAccountCredential != nil {
			newCred.ServiceAccount.ServiceAccountCredential = &ServiceAccountCredential{
				Type:                    c.ServiceAccount.ServiceAccountCredential.Type,
				ProjectID:               c.ServiceAccount.ServiceAccountCredential.ProjectID,
				PrivateKeyID:            c.ServiceAccount.ServiceAccountCredential.PrivateKeyID,
				PrivateKey:              c.ServiceAccount.ServiceAccountCredential.PrivateKey,
				ClientEmail:             c.ServiceAccount.ServiceAccountCredential.ClientEmail,
				ClientID:                c.ServiceAccount.ServiceAccountCredential.ClientID,
				AuthURI:                 c.ServiceAccount.ServiceAccountCredential.AuthURI,
				TokenURI:                c.ServiceAccount.ServiceAccountCredential.TokenURI,
				AuthProviderX509CertURL: c.ServiceAccount.ServiceAccountCredential.AuthProviderX509CertURL,
				ClientX509CertURL:       c.ServiceAccount.ServiceAccountCredential.ClientX509CertURL,
				UniverseDomain:          c.ServiceAccount.ServiceAccountCredential.UniverseDomain,
			}
		}
	}
	return newCred
}
